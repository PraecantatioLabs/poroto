# POROTO Pragmas

The POROTO toolchain uses pragmas in the source code for defining the external resources needed by the kernel and to configure the optimisations applied during the conversion process

All POROTO pragmas share the same first key word :

    #pragma poroto ...

## Stream definition

Streams are data path between memories and kernels. The default stream definition is as follow :

    #pragma poroto stream::<stream type> <function>::<stream name>(<memory name>, <item count>)

The defined stream will connect the stream point <stream name> of the kernel <function> to the memory <memory name>. When the kernel is activated, the stream will transfer <item count> of memory elements from the host memory to the FPGA memory or from the FPGA memory to the host memory, depending on the stream type.

The <stream type> defines the type of stream to be instanciated : Streams can be split into two categories, linear memory access, which is required by ROCCC interface, or random memory access which can be used for temporary memory pad or generic memory access.

### Linear stream

The linear stream can either access a BRAM memory directly or access any kind of memory using a OCP bus. The available <stream type> are :

* roccc\_ocp_in
* roccc\_ocp_out
* roccc\_bram_in
* roccc\_bram_out

### Random access stream

The random access stream can access any zone of a RAM at any time, but the downside is that the read latency is paid for each access. The available <stream type> are :

* bram
* bram_in
* bram_out

Note that not all stream types are available on all platforms.

## Memory definition

Memories used to store input data or kernel result must be explicitely defined using the following pragma :

    #pragma poroto memory <memory name> <data type> <memory size>

The <data type> is the C representation of the type of the memory element. It is used to calculate the size of each element, but also to generate the access code and wrappers.

The <memory size> is the maximum number of element stored in the memory. The actual number of element transfered is defined in the stream used to connect to the memory.

## External IP defintion

External IP must be declared in POROTO so that ROCCC knows it's interface and the IP can be included in the generated project. The IP interface is declared as an external C function, but the extra information must be given using extra pragma :

    #pragma poroto latency <latency>
    #pragma poroto file <category> <file>

The <latency> is the number of clock period needed to have the IP output valid after the input ready signal is triggered.

Extra file can be added to the generated project directly from the source code using the file pragma. The <category> field is used to define the destination of the file in the project.

## Code optimisations

The code transformation performed by ROCCC can be controled using code optimisation pragmas. These pragmas are simple on/off flags that are forwarded directly to ROCCC. They are applied only on the following function, not the file as a whole.

    #pragma poroto roccc <optimisation> [enable|disable]

If not specified, the _enable_ flag is assumed. See ROCCC_Optim.md for the detailed explanation of the flags.

The following flags are supported :

* TemporalCommonSubExpressionElimination
* MultiplyByConstElimination
* DivisionByConstElimination
* MaximizePrecision
* ArithmeticBalancing
* CopyReduction

By default, the following optimisation flags are set :

* MultiplyByConstElimination
* DivisionByConstElimination
* ArithmeticBalancing
* CopyReduction

### Loop optimisations

The loop control generated by ROCCC can be controled using the loop optimisation pragmas. These pragmas are applied to the given loop, identified by its label.

    #pragma poroto roccc <optimisation> ...

* LoopFusion
* LoopUnrolling <label> <count>|FULLY
* LoopInterchange <label 1> <label 2>
* InlineModule <function>
* InlineAllModules <depth>

See ROCCC_Optim.md for the detailed explanation of the optimisation.